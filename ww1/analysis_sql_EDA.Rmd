---
title: "Untitled"
output: html_document
---


```{r}
# install.packages(c('ggplot2', 'tidyr', 'ROCR', 'broom', 'readr',    
#                    'dplyr', 'DBI', 'RSQLite',
#                    'tibble', 'lattice', 'modelr', 'stringr', 'MASS', 
#                    'car',
#                    'caret', 'gridExtra', 'lsmeans', 'lme4'))

library(ggplot2)
#library(plotly)
library(dplyr)
library(tibble)
library(readr) # str_c, str_sub
library(tidyr)
library(broom) # tidy(model)
library(stringr)
library(modelr) # add_residuals
library(lattice) # splom
library(gridExtra) # grid.arrange
library(MASS) # for lm.ridge and boxcox, also fucks up dplyrs select 
library(car) # for vif
library(lsmeans) # for adjusted means
library(caret) # confusionMatrix
library(ROCR)
library(lme4) 


```


- derive associatiations
- use to esdtablish a graph
- then look for communities in that graph? / clusters?
    - notice the betweenness centrality based community detection would work well bc we can remove the people who are overlapping and be left w the communities 
    - think of a grocery store, various cuisines and then people who eat lots of different cuisines are screwing up your results
    
    
- knitting across different languages: 
    - (http://rmarkdown.rstudio.com/authoring_knitr_engines.html?utm_content=buffer5cc17&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer)
- data: https://blogs.technet.microsoft.com/dataplatforminsider/2016/06/09/wideworldimporters-the-new-sql-server-sample-database/
- ex: https://github.com/Microsoft/sql-server-samples/blob/master/samples/databases/wide-world-importers/sample-scripts/operational-analytics/DemonstrateOperationalAnalyticsPerformance.sql


# Goals
- unsupervised:
    - identify associations between products
    - rep products as a graph
    - get an idea for the similar products by grouping them
- supervised ideas:
    - forecast sales 
    - forecast whether sales persons sales are going to increase or decrease from 1 time period to the next (yearly)
    - recommend products based on associations
    - predict when we'll be undersupplied
    
- use:
    - cross reference w Customer Categories

```{r, max.print=10}
library(DBI)
library(RSQLite)
drv <- dbDriver('SQLite')
#db <- dbConnect(drv, 'C:\Program Files\Microsoft SQL Server\MSSQL13.SQLEXPRESS\MSSQL\DATA\WideWorldImporters.mdf')
#db <- dbConnect(drv, 'C:/Program Files/Microsoft SQL Server/MSSQL13.SQLEXPRESS/MSSQL/DATA/WideWorldImporters.mdf')
#db <- dbConnect(drv, 'C:/Program Files/Microsoft SQL Server/MSSQL13.SQLEXPRESS/MSSQL/DATA/music_Data.mdf')
#C:\Program Files\Microsoft SQL Server\MSSQL13.SQLEXPRESS\MSSQL\DATA\master.mdf
#db <- dbConnect(drv, 'C:/Program Files/Microsoft SQL Server/MSSQL13.SQLEXPRESS/MSSQL/DATA/music_Data')
# C:\Program Files\Microsoft SQL Server\MSSQL13.SQLEXPRESS\MSSQL\DATA\music_Data.mdf
# t2 <- 'C:\Program Files\Microsoft SQL Server\MSSQL13.SQLEXPRESS\MSSQL\DATA\WideWorldImporters_UserData.ndf'
# C:\Program Files\Microsoft SQL Server\MSSQL13.SQLEXPRESS\MSSQL\DATA\WideWorldImporters_InMemory_Data_1
# check were connected:
#db <- dbConnect(drv, 'sql.sqlite')
db <- dbConnect(RSQLite::SQLite(), dbname = "music_data")
dbListTables(db)
```

```{r, max.print=5}
library(RODBC) 
#db <- odbcDriverConnect('driver={SQL Server};server=localhost;database=WideWorldImporters;trusted_connection=true')
drv <- odbcDriverConnect('driver={SQL Server};server=THE-ENTERPRISE\\SQLEXPRESS;database=WideWorldImporters;trusted_connection=true')
sqlQuery(drv, 'select * from information_schema.tables')
```

```{r}
db <- dbConnect(drv, uid='THE-ENTERPRISE//brydon', dbname = "WideWorldImporters")
dbListTables(db)
```

```{r}
db <- dbConnect(RSQLite::SQLite(), uid='THE-ENTERPRISE/brydon', dbname = "WideWorldImporters")
dbListTables(db)
```


```{r}
conn <- odbcDriverConnect('driver={SQL Server};server=THE-ENTERPRISE\\SQLEXPRESS;database=WideWorldImporters;trusted_connection=true')
drv <- dbDriver('RODBC')
db <- dbConnect(conn=conn)
dbListTables(db)
```

```{r}
# require(RJDBC)
# drv <- RSQLite::SQLite()
#conn <- dbConnect(drv, "jdbc:THE-ENTERPRISE\\SQLEXPRESS", uid=)
drv <- dbDriver('SQLite')
conn <- dbConnect(drv, 'WideWorldImporters')
dbListTables(db)
```


```{r}
con <- odbcDriverConnect('driver={SQL Server};server=THE-ENTERPRISE\\SQLEXPRESS;database=WideWorldImporters;trusted_connection=true')
drv <- dbDriver('SQLite')
conn <- dbConnect(drv, con)
dbListTables(conn)
```

```{r}
#con <- odbcDriverConnect('driver={SQL Server};server=THE-ENTERPRISE\\SQLEXPRESS;database=WideWorldImporters;trusted_connection=true')
drv <- dbDriver('SQLite')
conn <- dbConnect(drv, 'WideWorldImporters-sqlite.db')
dbListTables(conn)
```

```{sql, connection=drv, max.print=10}
select * from Sales.Orders;
```

#### little exploration in sql
```{sql, connection=db}
select top 10 * from Sales.OrderLines;
select top 10 * from Sales.Orders;

select count(*)  from Sales.OrderLines;
select count(*) from Sales.Orders;

/* most and least popular items?*/
IF OBJECT_ID('tempdb..#rev_per_item_t1') IS NOT NULL DROP TABLE #rev_per_item_t1;

select 
	count(*) as n, 
	ix = 1,
	sum(UnitPrice * Quantity) as tot_rev_per_item,
	StockItemID, Description, UnitPrice
into #rev_per_item_t1
from Sales.Orders as orders
inner join Sales.OrderLines as info
	on orders.OrderID = info.OrderID
group by 
	StockItemID, Description, UnitPrice;


select t1.*, tot_rev_per_item / tot_rev as prop_of_tot_rev
into #rev_per_item
from 
	#rev_per_item_t1 as t1
inner join 
	(select 
		sum(tot_rev_per_item) as tot_rev,
		ix = 1
	from #rev_per_item_t1) as t2
	on t1.ix = t2.ix
order by tot_rev desc;


select top 100 * from #rev_per_item;
select top 100 * from #rev_per_item
order by tot_rev_per_item;

/*geographic presence*/
/*top sales talent*/
/*exersizes, similar to above*/
```

### lets make some dfs for us to work w locally
```{sql, connection=db, output.var='order_df'}
select
  t1.OrderID, CustomerID, StockItemID, Description
from Sales.Orders as t1
inner join Sales.OrderLines as t2
  on t1.OrderID = t2.OrderID
order by OrderID;
```

```{sql, connection=db, output.var='sales_df'}
select
  t1.OrderID, CustomerID, StockItemID, Description
from Sales.Orders as t1
inner join Sales.OrderLines as t2
  on t1.OrderID = t2.OrderID
inner join Application.
order by OrderID;
```

### EDA (R is the best for EDA)
- see chapter 7 of R4DS by hadley wickham: http://r4ds.had.co.nz/exploratory-data-analysis.html

#### best and worst months?
```{}

```


#### 

